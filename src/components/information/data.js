export const arr = [
  {
    title: 'props',
    discription:
      '{props.value} / {...array[0](номер элемента если имена пропса и переменной совпадают)}',
  },
  {
    title: 'useState',
    discription: "const [value, setValue] = useState('value'(начальное значение value))",
  },
  {
    title: 'children',
    discription:
      '{children}. Позволяет прописать разметку внутри дочернего компонента из родительского',
  },
  {
    title: 'Тернарники в разметке',
    discription: 'Можно использовать в разметке для достижения разных целей',
  },
  {
    title:
      '{array.map(elem => <Component key = {name.id} {... elem}(или условный title = {elem.title}) >)}',
    discription:
      'Эта запись - аналог v-for. Другими словами выводит все элементы из массива подставляя нужные значения(если нужно) в пропсы ',
  },
  {
    title: 'Работа с формами',
    discription:
      'Работа с формами тут достаточно сильно отличается от работы с формами VUE. Оно более сложное. нужно указать value = {name} (твой useState) и использовать функцию onChange={elem=>setName(elem)}. С одной стороны логично, с другой - не особо удобно и громостко',
  },
  {
    title: 'Работа с предыдущими состояниями',
    discription:
      'Это достаточно сложная тема, которая наверно прийдет только с практикой. В данном случае, если сильно упрощать, то нужно всегда держать в голове, что реактивная переменная не изменится до окончания функции и перерендера под капотом. Следовательно лучшей практикой, если вы хотите менять предыдущее значение реактивной переменной будет setValue((prev)=>!prev) (Пример на логических операциях более нагляден. Если мы пропишем в одной функции setValue(!value) и на некст строке setValue(!value), то по логике значение не поменяется, хотя по факту на сайте мы видим что будто первое приминилось, а второе - нет.)',
  },
  {
    title: 'useState - это не только массив из двух элементов',
    discription:
      'Да, в useState мы можем в качестве значения пихать не только переменную, но и объект состоящий из нескольких полей. Это прикольно, но есть загвостка. Если мы меняем одно значения поля, то должны обновить все поля. Иначе они потеряются',
  },
  {
    title: 'useRef',
    discription:
      'Что-то типо легаси ref во VUE, который нужен для взаимодействия с DOM элементами. Например с теми же самыми input полями, чекбоксами т.д.',
  },
  {
    title: 'createModal',
    discription: 'Позволяет вынести элемент куда угодно',
  },
  {
    title: 'useEffect(() =>, [])',
    discription:
      'Прикольная штука, которая по факту отслеживает изменения какой-либо переменной. Работает с такими элементами (например DOM), которые по факту еще не были объявлены. Другими словами оно регистрирует то, что нужно сделать, независимо от того был ли объявлен элемент. Если мы не передадим второй аргумент, побочный эффект в функции обратного вызова будет запускаться снова при каждой визуализации компонента. Если мы передаем второй аргумент в виде пустого массива, побочный эффект в функции обратного вызова сработает только один раз при первой визуализации компонента. Если мы передаем свойства или значения состояния во втором аргументе, побочный эффект в функции обратного вызова будет выполняться только при изменении значений свойств или переменной состояния.',
  },
  {
    title: 'Маршрутизатор',
    discription:
      'Маршрутизатор здесь состоит из 3 основных, базовых тегов: <BrowserRouter> (В нем должна находится как изменяемая чать, так и неизменяемая. Другими словами это должен быть тегом-родителем для всех остальных), <Routes> (в него записываются роуты. Проще говоря тег-хранилище роутов. Без него они работать не будут), <Route> (Тег в котором прописывается path = `путь, по которому будет объект` и element = `компонент который будет располагаться по этому пути`) и <Link> (ссылка для перехода по роуту. path куда будет переход пишется в to=`/path`). Либа - npm i react-router-dom',
  },
]
export const about = [
  {
    naming: 'Vue',
    info: 'Vue — JavaScript фреймворк для создания пользовательских интерфейсов. Он создан на стандартах HTML, CSS и JavaScript и предоставляет декларативную и компонентную модель программирования, которая помогает эффективно разрабатывать пользовательские интерфейсы любой сложности.',
  },
  {
    naming: 'React',
    info: 'React — это JavaScript-библиотека для создания пользовательских интерфейсов. Обратите внимание, что это именно библиотека, а не фреймворк. React часто называют фреймворком, но это ошибка. Во-первых, его использование ни к чему вас не обязывает, не формирует «фрейм» проекта. Во-вторых, React выполняет единственную задачу: показывает на странице компонент интерфейса, синхронизируя его с данными приложения, и только этой библиотеки в общем случае недостаточно для того, чтобы полностью реализовать проект.',
  },
  {
    naming: 'Angular',
    info: 'Angular — это фреймворк от компании Google для создания продвинутых бесшовных (одностраничных) веб-приложений — SPA (Single Page Applications) — на языках программирования TypeScript, JavaScript, Dart.',
  },
]
